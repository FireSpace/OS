11:04:2014
    man fcntl :
        O_NONBLOCK;
    man aio :
        асинхронный ввод-вывод;
        man aio.h;
    man select (как надо делать) :
        а, нет, не надо. Это старое и используется в винде (там нет poll);
    man poll :
        события, блокировка, вся хуйня;
        poll прерывается по сигналу (крашится к хуям);
        делаем poll :
            lock(Таблица файловых дескрипторов);
            unlock();
            n > 0  : (n, []);
            n == 0 : (тут нужно реализовать модное зависание) :
                В fdobject храним список тех, кто на него подписан;
                Когда пишем в pipe(допустим) — дергаем fdobject. А он уже 
                выкидывает из wait-очереди в poll-очередь;
            делаем epoll (видимо). Нам нужна производительнось за O(1);
            O(poll) = O(n(check) + n(in) + e(event) + n(out));
            man epoll : 
                epoll_create      O(1); //?
                epoll_ctl         O(n);
                epoll_wait        O(1);
        делаем ядро с epoll : 
            read : 
                create_req(...);
                me -> waiting;
                request.subscribe(me);
                fsinode.push_req(request);

    улучшаем ядро :
        {тут шла какая-то хуйня про симулирование continuation очередями, а я в это время в бессильном отчаянии обнимал Катю :(}
        {какие-то io_complete и r_complete очереди}
        {короч, хуярим кучу очередей и обрабатываем там каждый процесс до посинения}
        С точки зрения PLT — замена cont очередями — это как если бы у нас было бы cont-ядро и оно бы интепретировалось последовательным ядром; //хм, или наоборот ли
        А вообще, в реале у нас все это поддерживает железо с помощью интерраптов;
        man CPS-преобразование;


        ----Верхнее ядро
        ---Нижнее ядро
        --программа
        программа -> syscall -> Верхнее ядро -> в ВЯ приходит interrupt -> преобразуем -> Нижнее ядро -> генерим запрос в IOmanager -> IOmanager -> идем к дровам -> вернули результат -> вернули результат в НЯ -> программа узнает об этом (она в какой-то момент была подписана на этот результат, хуй знает когда :( )
       

16:05:2014
    Что-то про компиляцию/исполнение сишного кода.
    ELF (про вот это и рассказ)
    opcode
    .o file -> exec file
    Объектник — это программа с дырками. Если заткнем дырки — можно исполнять
    таблица релокаций .rel
    PLAN9
    .rpath
    Динамическая/Статическая линковки
    .lazy
    LD_PRELOAD
    R_PATH
    .o — дырки разбросаны по всему файлу (предполагается, что мы сделаем из него exeшник)
    .so — дырки собраны в самом начале. Таким образом все мапится на одну страницу и нам хорошо. (это динамическая библиотека)
    link graph
    copy relocation (воруем переменную из библиотеки себе) 
    realocation — генерация дырки
    jump table
    .GOT table
    .PLT table
    GOT.PLT
    Ленивая динамическая загрузка
    gmon_start


23:05:2014
    LLVM
    PNuCL
    asm.js
    Алгоритм Малаховски-Сорокина
        3 степени инициализации :
            1) она есть
            2) инцициализирована, но .GOT еще не заполнен
            3) заполнен .GOT
        инициализация библиотеки без зависимостей
    .GOT .PLT локальны для каждой библиотеки
    
30:05:2014
    домашка на 0 баллов
    асинхронное чтение-запись 
        epoll
            p.read(fd, buf, rc, ec) //rc, ec — коллбеки
            p.write(fd, buf, wc, ec) //wc, ec — коллбеки
            p.cancell_read(fd)
            p.cancell_write(fd)
        
    сокеты
    cps-преобразование
    epoll : оптимизация. Сделать diff (те, для кого мы будем сейчас смотреть)
потом функцию loop, которая будет заведовать этим diff

6:06:2014 Планирование

    Статическое планирование
        Ну давайте у нас есть функции. Некоторые должны вызываться чаще, некоторые реже. Давайте дадим им
приритеты и просуммируем. У нас получится такой Блок. [                             ] Ну давайте теперь распределим
по нему в соответиствии с приоритетами. 
        Вообще, это крайне полезная штука, поэтому существует куча фреймворков для разных языков программирования, которые
принимают приоритеты и функции и генерируют сишный код, который будет правильно распределять вызовы. 
        С точки зрения процессора, раз в некоторое время вызывается какой-то интеррапт, на котором что-то происходит.

    Динамическое планирование
        Состояния процесса:
            1) Running
            2) Run ?? 
            3) Waiting
            4) Interrupt

        Планировщики:
            FIFO                             - самые простые
            RR — round-robin                 - самые простые

    --Часть лекции пропущена...
    
def:Real priority (man nice)
def:Eff priority (сколько времени будет выполнятся процесс)
    
    Проблемы:
        Пусть у нас есть H, M, L процессы. (имена — это приоритеты)
        Пусть выполняется L, заблокировал что-то. Потом он прекращает исполнения и одновременно хотят работать
H и M, но H нужны данные, которые заблокировал L. Теперь у нас будет бесконечно исполнятся M, потому что H
мы запустить не можем, а у L приоритет меньше.
    
    Решение проблемы:
        Инверсия приоритетов:
            Введем приоритеты на блокировки. 
            Приоритет блокировки — максимальный из приоритетов держащих её штук.
            
        Итог: Эффективные приоритеты сильно не соответствуют реальным

    Планирование ввода-вывода с жесткого диска:
        --опять я баловался с хаскеллем, вместо лекции :(

    Планирование Сети:
        Алгоритм дырявого ведра:
            Ну типа у нас есть буффер, куда мы складываем данные как хотим, а он пропускает уже с некоторой постоянной скоростью
            Теперь у нас нагрузка на сеть — гладкая функция. Хорошо это тем, что хабы на пути могут предсказать,
когда наступит жопа и сказать: "чуваки¸ давайте помедленней".
            
        Все это мы делали потому, что при переполнении буффера на пути теряется часть пакетов, а это, в свою очередь,
        заставляет нас делать какой-то ресет, затраты на который сильно накладны.

    Реальная жизнь:
    |
    |
    |realtime 
    -----------
    |
    |
    |proportional
    ------------
    | BATCH — совсем ненужная хрень, которой мы занимаемся тогда, когда нам нечего больше делать


    А еще в реальной жизни мы не сможешь реалайм делать планирование, поэтому используются всякие приблизительные планировщики.
    CFQ
    HTSC
    QOS TOS
    Надо настроить QOS/TOS для себя.
    man shed_*, nice, renice, ionice
