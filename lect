11:04:2014
    man fcntl :
        O_NONBLOCK;
    man aio :
        асинхронный ввод-вывод;
        man aio.h;
    man select (как надо делать) :
        а, нет, не надо. Это старое и используется в винде (там нет poll);
    man poll :
        события, блокировка, вся хуйня;
        poll прерывается по сигналу (крашится к хуям);
        делаем poll :
            lock(Таблица файловых дескрипторов);
            unlock();
            n > 0  : (n, []);
            n == 0 : (тут нужно реализовать модное зависание) :
                В fdobject храним список тех, кто на него подписан;
                Когда пишем в pipe(допустим) — дергаем fdobject. А он уже 
                выкидывает из wait-очереди в poll-очередь;
            делаем epoll (видимо). Нам нужна производительнось за O(1);
            O(poll) = O(n(check) + n(in) + e(event) + n(out));
            man epoll : 
                epoll_create      O(1); //?
                epoll_ctl         O(n);
                epoll_wait        O(1);
        делаем ядро с epoll : 
            read : 
                create_req(...);
                me -> waiting;
                request.subscribe(me);
                fsinode.push_req(request);

    улучшаем ядро :
        {тут шла какая-то хуйня про симулирование continuation очередями, а я в это время в бессильном отчаянии обнимал Катю :(}
        {какие-то io_complete и r_complete очереди}
        {короч, хуярим кучу очередей и обрабатываем там каждый процесс до посинения}
        С точки зрения PLT — замена cont очередями — это как если бы у нас было бы cont-ядро и оно бы интепретировалось последовательным ядром; //хм, или наоборот ли
        А вообще, в реале у нас все это поддерживает железо с помощью интерраптов;
        man CPS-преобразование;


        ----Верхнее ядро
        ---Нижнее ядро
        --программа
        программа -> syscall -> Верхнее ядро -> в ВЯ приходит interrupt -> преобразуем -> Нижнее ядро -> генерим запрос в IOmanager -> IOmanager -> идем к дровам -> вернули результат -> вернули результат в НЯ -> программа узнает об этом (она в какой-то момент была подписана на этот результат, хуй знает когда :( )
       

16:05:2014
    Что-то про компиляцию/исполнение сишного кода.
    ELF (про вот это и рассказ)
    opcode
    .o file -> exec file
    Объектник — это программа с дырками. Если заткнем дырки — можно исполнять
    таблица релокаций .rel
    PLAN9
    .rpath
    Динамическая/Статическая линковки
    .lazy
    LD_PRELOAD
    R_PATH
    .o — дырки разбросаны по всему файлу (предполагается, что мы сделаем из него exeшник)
    .so — дырки собраны в самом начале. Таким образом все мапится на одну страницу и нам хорошо. (это динамическая библиотека)
    link graph
    copy relocation (воруем переменную из библиотеки себе) 
    realocation — генерация дырки
    jump table
    .GOT table
    .PLT table
    GOT.PLT
    Ленивая динамическая загрузка
    gmon_start


23:05:2014
    LLVM
    PNuCL
    asm.js
    Алгоритм Малаховски-Сорокина
        3 степени инициализации :
            1) она есть
            2) инцициализирована, но .GOT еще не заполнен
            3) заполнен .GOT
        инициализация библиотеки без зависимостей
    .GOT .PLT локальны для каждой библиотеки
    
30:05:2014
    домашка на 0 баллов
    асинхронное чтение-запись 
        epoll
            p.read(fd, buf, rc, ec) //rc, ec — коллбеки
            p.write(fd, buf, wc, ec) //wc, ec — коллбеки
            p.cancell_read(fd)
            p.cancell_write(fd)
        
    сокеты
    cps-преобразование
    epoll : оптимизация. Сделать diff (те, для кого мы будем сейчас смотреть)
потом функцию loop, которая будет заведовать этим diff
