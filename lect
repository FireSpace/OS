11:04:2014
    man fcntl :
        O_NONBLOCK;
    man aio :
        асинхронный ввод-вывод;
        man aio.h;
    man select (как надо делать) :
        а, нет, не надо. Это старое и используется в винде (там нет poll);
    man poll :
        события, блокировка, вся хуйня;
        poll прерывается по сигналу (крашится к хуям);
        делаем poll :
            lock(Таблица файловых дескрипторов);
            unlock();
            n > 0  : (n, []);
            n == 0 : (тут нужно реализовать модное зависание) :
                В fdobject храним список тех, кто на него подписан;
                Когда пишем в pipe(допустим) — дергаем fdobject. А он уже 
                выкидывает из wait-очереди в poll-очередь;
            делаем epoll (видимо). Нам нужна производительнось за O(1);
            O(poll) = O(n(check) + n(in) + e(event) + n(out));
            man epoll : 
                epoll_create      O(1); //?
                epoll_ctl         O(n);
                epoll_wait        O(1);
        делаем ядро с epoll : 
            read : 
                create_req(...);
                me -> waiting;
                request.subscribe(me);
                fsinode.push_req(request);

    улучшаем ядро :
        {тут шла какая-то хуйня про симулирование continuation очередями, а я в это время в бессильном отчаянии обнимал Катю :(}
        {какие-то io_complete и r_complete очереди}
        {короч, хуярим кучу очередей и обрабатываем там каждый процесс до посинения}
        С точки зрения PLT — замена cont очередями — это как если бы у нас было бы cont-ядро и оно бы интепретировалось последовательным ядром; //хм, или наоборот ли
        А вообще, в реале у нас все это поддерживает железо с помощью интерраптов;
        man CPS-преобразование;


        ----Верхнее ядро
        ---Нижнее ядро
        --программа
        программа -> syscall -> Верхнее ядро -> в ВЯ приходит interrupt -> преобразуем -> Нижнее ядро -> генерим запрос в IOmanager -> IOmanager -> идем к дровам -> вернули результат -> вернули результат в НЯ -> программа узнает об этом (она в какой-то момент была подписана на этот результат, хуй знает когда :( )
        
